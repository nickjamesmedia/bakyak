<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BakYak — Collapsible Kayak Backpack | Coming Soon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="BakYak (Bak-Yak Inc.) — the collapsible kayak you carry as a backpack. Coming soon." />
  <link rel="canonical" href="https://bakyak.ca/">
  <meta name="theme-color" content="#C8692D" />
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self';
                 img-src 'self' data:;
                 style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
                 font-src https://fonts.gstatic.com;
                 script-src 'self' 'unsafe-inline';
                 frame-ancestors 'none'">
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@1,700&display=swap" rel="stylesheet">
  <style>
    :root{
      --light:#82C4D8;  /* water (light) */
      --dark:#3249A2;   /* waves (dark) */
      --text:#C8692D;   /* burnt orange */
    }
    html,body{
      height:100%;
      margin:0;
      background:var(--light);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      text-rendering:optimizeLegibility;
    }
    .wrap{position:relative;width:100vw;height:100vh;overflow:hidden;}
    .mast{
      position:fixed;top:12px;left:50%;transform:translateX(-50%);
      font:italic 700 28px/1 "Barlow",system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;
      letter-spacing:.02em;user-select:none;text-shadow:0 1px 0 #ffffff66;
    }
    #game{width:100%;height:100%;display:block;touch-action:manipulation;}
    .hint{
      position:fixed;left:12px;bottom:12px;
      font:600 12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;
      color:var(--text);background:#ffffff66;padding:6px 8px;border-radius:6px;
      user-select:none;backdrop-filter:blur(4px);opacity:0;transition:opacity .8s ease;
    }
    .hint.show{opacity:.9;}
    .copy{
      position:fixed;right:12px;bottom:10px;
      font:600 12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;
      color:var(--text);text-shadow:0 1px 0 #ffffff66;user-select:none;
    }
    @media (prefers-reduced-motion: reduce){#game{animation:none;}}
  </style>
</head>
<body>
  <div class="wrap" aria-label="BakYak coming soon interactive scene">
    <div class="mast" aria-hidden="true">coming soon…</div>
    <canvas id="game"></canvas>
    <div class="hint" id="hint">Click to move the kayak</div>
    <div class="copy">© <span id="year"></span> Bak-Yak Inc.</div>
  </div>
  <noscript>This page is interactive. Enable JavaScript to play with the kayak.</noscript>

  <script>
  (() => {
    'use strict';
    // ---- Helpers / Config ----
    const COLOR_LIGHT = css('--light','#82C4D8');
    const COLOR_DARK  = css('--dark', '#3249A2');
    const COLOR_KAYAK = '#C8692D';
    function css(v,f){ const x=getComputedStyle(document.documentElement).getPropertyValue(v).trim(); return x||f; }
    function clamp(v,lo,hi){ return Math.max(lo,Math.min(hi,v)); }
    const mm = (q)=> (typeof matchMedia==='function' ? matchMedia(q) : {matches:false, addEventListener:()=>{}, removeEventListener:()=>{}});

    // ---- Canvas ----
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
    let width=0, height=0;

    // ---- Time / state ----
    let timeSec = 0, last = performance.now();
    const prefersReduce = mm('(prefers-reduced-motion: reduce)').matches;

    // ---- Boat assets (logo + kayak as one "boat" element) ----
    const logoImg = new Image();  logoImg.decoding='async';  logoImg.src='assets/logo.svg';
    const kayakImg = new Image(); kayakImg.decoding='async'; kayakImg.src='assets/kayak.svg';
    let logoLoaded=false, kayakLoaded=false;
    logoImg.onload = ()=>{ logoLoaded=true; };
    kayakImg.onload= ()=>{ kayakLoaded=true; };
    logoImg.onerror = ()=>{ logoLoaded=false; };
    kayakImg.onerror= ()=>{ kayakLoaded=false; };

    // ---- Kayak base sizes (desktop vs mobile) ----
    const BASE_LENGTH_DESKTOP = 125;
    const BASE_LENGTH_MOBILE  = BASE_LENGTH_DESKTOP * 0.5;
    const mobileMQ = mm('(max-width: 640px)');
    let targetLength = mobileMQ.matches ? BASE_LENGTH_MOBILE : BASE_LENGTH_DESKTOP;
    let currentLength = targetLength; // eased
    const SIZE_EASE_PER_SEC = 6; // exp ease rate

    mobileMQ.addEventListener?.('change', (e)=>{
      targetLength = e.matches ? BASE_LENGTH_MOBILE : BASE_LENGTH_DESKTOP;
    });

    // ---- Boat state ----
    const NORTH = -Math.PI/2;
    const MODE = { LOGO_IDLE:'LOGO_IDLE', TRANSITION:'TRANSITION', ACTIVE:'ACTIVE' };
    let mode = MODE.LOGO_IDLE;              // start with the full logo
    let lastUserTime = 0;                   // seconds since start of app time
    const IDLE_AFTER = 12;                  // seconds

    // movement tuning (keep your current feel)
    const kayak = {
      x:0, y:0,
      angle:NORTH,              // start facing north
      tx:0, ty:0,
      maxSpeed:260, arriveGain:2.0,
      rollAmp:0.03, rollSpeed:0.8,
      heaveAmp:0.4,
      speed:0, turnRate:2.5
    };
    let initialized=false;

    // ---- Wake (values scale with length each frame) ----
    const wake = { points:[], maxAge:1.6, minSpeed:40 };

    // ---- Resize ----
    function resize(){
      dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
      const w = canvas.clientWidth, h = canvas.clientHeight;
      canvas.width = Math.round(w*dpr); canvas.height = Math.round(h*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      width=w; height=h;
      if(!initialized){
        kayak.x=width/2; kayak.y=height/2; kayak.tx=kayak.x; kayak.ty=kayak.y; initialized=true;
      }else{
        kayak.x=clamp(kayak.x,0,width); kayak.y=clamp(kayak.y,0,height);
        kayak.tx=clamp(kayak.tx,0,width); kayak.ty=clamp(kayak.ty,0,height);
      }
      targetLength = mobileMQ.matches ? BASE_LENGTH_MOBILE : BASE_LENGTH_DESKTOP;
    }
    addEventListener('resize', resize, {passive:true}); resize();

    // ---- Waves: abstract ribbons rotated NNE->SSW, plus controllable drift ----
    const WAVE_ROT = -Math.PI * 0.375; // -67.5°
    const cosNegRot = Math.cos(-WAVE_ROT), sinNegRot = Math.sin(-WAVE_ROT);

    const waves = {
      thickness: 28,
      baseAmp: 10,
      rowGap: 56,
      speedA: prefersReduce?0:0.55,
      speedB: prefersReduce?0:-0.22,
      dx: 5
    };

    // wave "flow" offset (so motion can point toward center in idle/transition)
    let waveFlowX = 0, waveFlowY = 0;
    const WAVE_FLOW_SPEED = 12;       // px/sec in rotated space
    const WAVE_FLOW_DECAY = 0.9;      // decay when not idle/transition (per second)

    // simple value noise
    function nrand(i){ let x = Math.sin(i*127.1)*43758.5453; return x - Math.floor(x); }
    function noise1(x, seed=0){
      const s = x*0.015 + seed*19.19;
      const i = Math.floor(s), f = s - i;
      const a = nrand(i*1.3+seed), b = nrand((i+1)*1.3+seed);
      const u = f*f*(3-2*f);
      return a*(1-u) + b*u;
    }
    function yWave(x, base, t, rowSeed){
      const k1 = 2*Math.PI/210, k2 = 2*Math.PI/137, k3 = 2*Math.PI/89;
      const p1 = k1*x + t*waves.speedA + rowSeed*1.3;
      const p2 = k2*x - t*waves.speedB + rowSeed*2.1;
      const p3 = k3*x + t*(waves.speedA*0.37) - rowSeed*0.7;
      const amp = waves.baseAmp * (0.8 + 0.6*noise1(x*0.4 + rowSeed*7));
      const jitter = (noise1(x*0.9 + t*0.15 + rowSeed*3)-0.5)*6;
      return base + (Math.sin(p1)*0.9 + Math.sin(p2)*0.5 + Math.sin(p3)*0.25)*amp + jitter;
    }

    function drawWaves(t){
      ctx.fillStyle = COLOR_LIGHT; ctx.fillRect(0,0,width,height);

      // draw in a rotated space so bands are NNE->SSW
      const diag = Math.hypot(width, height);
      const W = diag, H = diag;

      ctx.save();
      ctx.translate(width/2, height/2);
      ctx.rotate(WAVE_ROT);
      ctx.translate(-W/2, -H/2);

      // apply controllable drift offset (in rotated space)
      ctx.translate(waveFlowX, waveFlowY);

      ctx.fillStyle = COLOR_DARK;
      drawLayer(t, 0.0, waves.rowGap, 0, W, H);
      ctx.globalAlpha = 0.75;
      drawLayer(t+3.1, waves.rowGap*0.5, waves.rowGap*0.92, 1, W, H);
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    function drawLayer(t, yOffset, gap, seed, W, H){
      for(let base = yOffset - 60; base < H + gap; base += gap){
        drawRibbon(base, t, seed, W, H);
      }
    }
    function drawRibbon(base, t, seed, W, H){
      const thick = waves.thickness, dx = waves.dx;
      ctx.beginPath();
      let x=0, y=yWave(0, base, t, seed);
      ctx.moveTo(0, y - thick/2);
      for(x=0; x<=W; x+=dx){ y = yWave(x, base, t, seed); ctx.lineTo(x, y - thick/2); }
      for(x=W; x>=0; x-=dx){ y = yWave(x, base, t, seed); ctx.lineTo(x, y + thick/2); }
      ctx.closePath(); ctx.fill();
    }

    // ---- Motion / state ----
    function angDiff(a,b){ let d=(b-a+Math.PI)%(2*Math.PI); if(d<0)d+=2*Math.PI; return d-Math.PI; }
    const IDLE_DIST = 0.5;

    function setMode(newMode){
      mode = newMode;
      // reset wave flow gradually based on mode switch
      if (mode === MODE.ACTIVE){
        // let flow decay toward 0
      }
      // in transition/idle, flow direction will be set each frame toward center
    }

    function updateBoatAndWaves(dt){
      // size easing (mobile/desktop)
      const k = Math.min(1, SIZE_EASE_PER_SEC * dt);
      currentLength += (targetLength - currentLength) * k;

      const cx = width/2, cy = height/2;

      // ---- choose behavior per mode ----
      if (mode === MODE.ACTIVE){
        const dx = kayak.tx-kayak.x, dy = kayak.ty-kayak.y, dist = Math.hypot(dx,dy);
        const px = kayak.x, py = kayak.y;
        if (dist > IDLE_DIST){
          const dirX=dx/dist, dirY=dy/dist;
          const desired=Math.min(kayak.maxSpeed, dist*kayak.arriveGain);
          kayak.x += dirX*desired*dt; kayak.y += dirY*desired*dt;

          const desiredAngle = Math.atan2(dirY,dirX);
          const diff = angDiff(kayak.angle, desiredAngle);
          const maxStep = kayak.turnRate*dt;
          kayak.angle += Math.sign(diff)*Math.min(Math.abs(diff), maxStep);
        }
        kayak.speed = Math.hypot(kayak.x - px, kayak.y - py) / dt;

        // waves: decay flow when active
        const decay = Math.pow(WAVE_FLOW_DECAY, dt); // per-sec decay
        waveFlowX *= decay; waveFlowY *= decay;

        // kick to TRANSITION after 12s of inactivity (and only if basically stopped)
        const since = timeSec - lastUserTime;
        if (since >= IDLE_AFTER && dist <= IDLE_DIST){
          setMode(MODE.TRANSITION);
          // set a gentle target to center
          kayak.tx = cx; kayak.ty = cy;
        }
      }
      else if (mode === MODE.TRANSITION){
        // move position toward center
        const dx = cx-kayak.x, dy = cy-kayak.y, dist = Math.hypot(dx,dy);
        const dirX = dist>1e-3 ? dx/dist : 0, dirY = dist>1e-3 ? dy/dist : 0;
        const desired = Math.min(kayak.maxSpeed*0.55, dist * (kayak.arriveGain*0.9)); // gentler
        kayak.x += dirX * desired * dt; kayak.y += dirY * desired * dt;
        kayak.speed = desired; // approximate, fine for wake sampling

        // rotate toward NORTH regardless of path
        const diff = angDiff(kayak.angle, NORTH);
        const maxStep = (kayak.turnRate*0.7) * dt; // rotate gently
        if (Math.abs(diff) <= maxStep) kayak.angle = NORTH;
        else kayak.angle += Math.sign(diff) * maxStep;

        // wave flow: push toward center
        if (dist > 1){
          const vx = dx/dist, vy = dy/dist; // screen-space to center
          // rotate into wave space (which was rotated by WAVE_ROT)
          const vrx = vx * cosNegRot - vy * sinNegRot;
          const vry = vx * sinNegRot + vy * cosNegRot;
          waveFlowX += vrx * WAVE_FLOW_SPEED * dt;
          waveFlowY += vry * WAVE_FLOW_SPEED * dt;
          // keep offsets bounded (wrap roughly by rowGap)
          const wrap = waves.rowGap;
          if (waveFlowX >  2*wrap) waveFlowX -= 2*wrap; if (waveFlowX < -2*wrap) waveFlowX += 2*wrap;
          if (waveFlowY >  2*wrap) waveFlowY -= 2*wrap; if (waveFlowY < -2*wrap) waveFlowY += 2*wrap;
        }

        // when close enough to north, switch to LOGO_IDLE
        if (Math.abs(angDiff(kayak.angle, NORTH)) < 0.04){ // ~2.3°
          setMode(MODE.LOGO_IDLE);
        }
      }
      else if (mode === MODE.LOGO_IDLE){
        // keep facing north
        kayak.angle = NORTH;

        // gentle drift toward exact center (very slow)
        const dx = cx-kayak.x, dy = cy-kayak.y, dist = Math.hypot(dx,dy);
        if (dist > 0.25){
          const dirX = dx/dist, dirY = dy/dist;
          const drift = Math.min(18, dist*2); // px/sec, mild
          kayak.x += dirX * drift * dt; kayak.y += dirY * drift * dt;
        }

        // wave flow toward center
        if (dist > 0.25){
          const vx = dx/dist, vy = dy/dist;
          const vrx = vx * cosNegRot - vy * sinNegRot;
          const vry = vx * sinNegRot + vy * cosNegRot;
          waveFlowX += vrx * WAVE_FLOW_SPEED * dt;
          waveFlowY += vry * WAVE_FLOW_SPEED * dt;

          const wrap = waves.rowGap;
          if (waveFlowX >  2*wrap) waveFlowX -= 2*wrap; if (waveFlowX < -2*wrap) waveFlowX += 2*wrap;
          if (waveFlowY >  2*wrap) waveFlowY -= 2*wrap; if (waveFlowY < -2*wrap) waveFlowY += 2*wrap;
        }
      }
    }

    // ---- Wake ----
    function updateWake(dt){
      for (let i=0;i<wake.points.length;i++) wake.points[i].age+=dt;
      while(wake.points.length && wake.points[0].age>wake.maxAge) wake.points.shift();

      const sternOffset = (currentLength/2 - 2);
      if(kayak.speed > wake.minSpeed && mode !== MODE.LOGO_IDLE){
        const sx = kayak.x - Math.cos(kayak.angle)*sternOffset;
        const sy = kayak.y - Math.sin(kayak.angle)*sternOffset;
        const last = wake.points[wake.points.length-1];
        const sampleDist = currentLength * 0.028; // proportional
        if(!last || Math.hypot(sx-last.x, sy-last.y) >= sampleDist){
          wake.points.push({x:sx,y:sy,age:0});
        }
      }
    }
    function drawWake(){
      const pts=wake.points; if(pts.length<2) return;
      ctx.save(); ctx.strokeStyle='#fff'; ctx.lineCap='round'; ctx.lineJoin='round';
      for(let i=1;i<pts.length;i++){
        const p0=pts[i-1], p1=pts[i];
        const a = Math.min(1 - p0.age/wake.maxAge, 1 - p1.age/wake.maxAge);
        if(a<=0) continue;
        const spreadMax = currentLength * 0.13;

        ctx.globalAlpha=0.18*a*a; ctx.lineWidth=6*a;
        ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();

        const vx=p1.x-p0.x, vy=p1.y-p0.y, len=Math.hypot(vx,vy);
        if(len>1e-3){
          const nx=vx/len, ny=vy/len, px=-ny, py=nx;
          const s0=spreadMax*(1 - p0.age/wake.maxAge);
          const s1=spreadMax*(1 - p1.age/wake.maxAge);
          ctx.globalAlpha=0.12*a*a; ctx.lineWidth=3*a;
          ctx.beginPath(); ctx.moveTo(p0.x+px*s0,p0.y+py*s0); ctx.lineTo(p1.x+px*s1,p1.y+py*s1); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(p0.x-px*s0,p0.y-py*s0); ctx.lineTo(p1.x-px*s1,p1.y-py*s1); ctx.stroke();
        }
      }
      ctx.restore();
    }

    // ---- Draw Boat (logo or kayak; same element/transform/size) ----
    function drawBoat(t){
      ctx.save();
      // slight heave + port/starboard roll (even in idle, keep tiny life)
      const heave = Math.sin(t * kayak.rollSpeed * 2*Math.PI) * kayak.heaveAmp;
      const roll  = Math.sin(t * kayak.rollSpeed * 2*Math.PI) * kayak.rollAmp;

      ctx.translate(kayak.x, kayak.y + heave);
      ctx.rotate(kayak.angle + roll);

      const L = currentLength;
      // For SVGs that face north: rotate +90° so "forward" is +X before our yaw
      const drawAsLogo = (mode === MODE.LOGO_IDLE) && logoLoaded;
      if (drawAsLogo){
        ctx.rotate(Math.PI/2);
        const targetH = L;
        const ratio = logoImg.naturalWidth / logoImg.naturalHeight || 1;
        const w = targetH * ratio, h = targetH;
        ctx.drawImage(logoImg, -w/2, -h/2, w, h);
      } else if (kayakLoaded){
        ctx.rotate(Math.PI/2);
        const targetH = L;
        const ratio = kayakImg.naturalWidth / kayakImg.naturalHeight || 1;
        const w = targetH * ratio, h = targetH;
        ctx.drawImage(kayakImg, -w/2, -h/2, w, h);
      } else {
        // fallback hull (burnt orange)
        const W = L * (40/140);
        ctx.fillStyle=COLOR_KAYAK; ctx.strokeStyle=COLOR_DARK; ctx.lineWidth=2;
        ctx.beginPath();
        ctx.moveTo(+L/2,0);
        ctx.quadraticCurveTo(+L/6,-W/2,0,-W/2.4);
        ctx.quadraticCurveTo(-L/3,-W/3,-L/2,0);
        ctx.quadraticCurveTo(-L/3,+W/3,0,+W/2.4);
        ctx.quadraticCurveTo(+L/6,+W/2,+L/2,0);
        ctx.closePath(); ctx.fill(); ctx.stroke();
      }
      ctx.restore();
    }

    // ---- Ripple (still shows on clicks) ----
    const ripple={x:0,y:0,t0:-10};
    function drawRipple(t){
      const e=t-ripple.t0; if(e<0||e>1.2) return;
      const a=1-(e/1.2);
      ctx.save(); ctx.translate(ripple.x,ripple.y); ctx.strokeStyle=COLOR_DARK; ctx.globalAlpha=0.35*a; ctx.lineWidth=2;
      circle(e*140); circle(16+e*180); ctx.restore();
      function circle(r){ ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke(); }
    }

    // ---- Input & Hint logic (inactivity-based) ----
    const hint = document.getElementById('hint');
    let hintTimer=null;
    function scheduleHint(){
      if(hintTimer) clearTimeout(hintTimer);
      hint.classList.remove('show');
      hintTimer = setTimeout(()=>hint.classList.add('show'), 30000); // show after 30s idle
    }
    scheduleHint();

    function moveBoatTo(x,y){
      kayak.tx=x; kayak.ty=y;
      ripple.x=x; ripple.y=y; ripple.t0=timeSec;
    }
    canvas.addEventListener('pointerdown',(e)=>{
      const r=canvas.getBoundingClientRect();
      moveBoatTo(e.clientX - r.left, e.clientY - r.top);
      lastUserTime = timeSec;
      // switch to ACTIVE immediately and draw kayak
      setMode(MODE.ACTIVE);
      hint.classList.remove('show');
      scheduleHint();
    }, {passive:true});

    // Pause hint timer when tab hidden (resume on return)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) { if (hintTimer) clearTimeout(hintTimer); }
      else { scheduleHint(); }
    });

    // ---- Misc ----
    document.getElementById('year').textContent = new Date().getFullYear();

    // ---- Main loop ----
    function frame(now){
      const dt=Math.min(0.033,(now-last)/1000); last=now; timeSec+=dt;
      updateBoatAndWaves(dt);
      updateWake(dt);
      drawWaves(timeSec);
      drawWake();
      drawRipple(timeSec);
      drawBoat(timeSec);
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>

  <script type="application/ld+json">
  {"@context":"https://schema.org","@type":"Organization","name":"Bak-Yak Inc.","alternateName":"BakYak","url":"https://bakyak.ca","logo":"https://bakyak.ca/assets/logo.svg"}
  </script>
</body>
</html>
