<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BakYak — Collapsible Kayak Backpack | Coming Soon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="BakYak (Bak-Yak Inc.) — the collapsible kayak you carry as a backpack. Coming soon." />
  <link rel="canonical" href="https://bakyak.ca/">
  <meta name="theme-color" content="#C8692D" />
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self';
                 img-src 'self' data:;
                 style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
                 font-src https://fonts.gstatic.com;
                 script-src 'self' 'unsafe-inline';
                 frame-ancestors 'none'">
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@1,700&display=swap" rel="stylesheet">
  <style>
    :root{
      --light:#82C4D8;  /* water (light) */
      --dark:#3249A2;   /* waves (dark) */
      --text:#C8692D;   /* burnt orange */
    }
    html,body{
      height:100%;
      margin:0;
      background:var(--light);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      text-rendering:optimizeLegibility;
    }
    .wrap{position:relative;width:100vw;height:100vh;overflow:hidden;}
    .mast{
      position:fixed;top:12px;left:50%;transform:translateX(-50%);
      font:italic 700 28px/1 "Barlow",system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;
      letter-spacing:.02em;user-select:none;text-shadow:0 1px 0 #ffffff66;
    }
    #game{width:100%;height:100%;display:block;touch-action:manipulation;}
    .hint{
      position:fixed;left:12px;bottom:12px;
      font:600 12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;
      color:var(--text);background:#ffffff66;padding:6px 8px;border-radius:6px;
      user-select:none;backdrop-filter:blur(4px);opacity:0;transition:opacity .8s ease;
    }
    .hint.show{opacity:.9;}
    .copy{
      position:fixed;right:12px;bottom:10px;
      font:600 12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;
      color:var(--text);text-shadow:0 1px 0 #ffffff66;user-select:none;
    }
    @media (prefers-reduced-motion: reduce){#game{animation:none;}}
  </style>
</head>
<body>
  <div class="wrap" aria-label="BakYak coming soon interactive scene">
    <div class="mast" aria-hidden="true">coming soon…</div>
    <canvas id="game"></canvas>
    <div class="hint" id="hint">Click to move the kayak</div>
    <div class="copy">© <span id="year"></span> Bak-Yak Inc.</div>
  </div>
  <noscript>This page is interactive. Enable JavaScript to play with the kayak.</noscript>

  <script>
  (() => {
    'use strict';

    // ---------- Helpers / Config ----------
    const COLOR_LIGHT = css('--light','#82C4D8');
    const COLOR_DARK  = css('--dark', '#3249A2');
    const COLOR_KAYAK = '#C8692D';
    function css(v,f){ const x=getComputedStyle(document.documentElement).getPropertyValue(v).trim(); return x||f; }
    function clamp(v,lo,hi){ return Math.max(lo,Math.min(hi,v)); }
    const mm = (q)=> (typeof matchMedia==='function' ? matchMedia(q) : {matches:false, addEventListener:()=>{}, removeEventListener:()=>{}});

    // ---------- Canvas ----------
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
    let width=0, height=0;

    // ---------- Time / state ----------
    let timeSec = 0, last = performance.now();
    const prefersReduce = mm('(prefers-reduced-motion: reduce)').matches;

    // ---------- Assets (logotype + kayak share same transform) ----------
    const logoImg = new Image();   logoImg.decoding='async';  logoImg.src='assets/logotype.svg';
    const kayakImg = new Image();  kayakImg.decoding='async'; kayakImg.src='assets/kayak.svg';
    let logoLoaded=false, kayakLoaded=false;
    logoImg.onload = ()=>{ logoLoaded=true; };
    kayakImg.onload= ()=>{ kayakLoaded=true; };
    logoImg.onerror = ()=>{ logoLoaded=false; };
    kayakImg.onerror= ()=>{ kayakLoaded=false; };

    // ---------- Responsive size (desktop vs mobile) ----------
    const BASE_LENGTH_DESKTOP = 125;
    const BASE_LENGTH_MOBILE  = BASE_LENGTH_DESKTOP * 0.5;
    const mobileMQ = mm('(max-width: 640px)');
    let targetLength = mobileMQ.matches ? BASE_LENGTH_MOBILE : BASE_LENGTH_DESKTOP;
    let currentLength = targetLength;       // eased
    const SIZE_EASE_PER_SEC = 6;            // exp ease rate

    mobileMQ.addEventListener?.('change', (e)=>{
      targetLength = e.matches ? BASE_LENGTH_MOBILE : BASE_LENGTH_DESKTOP;
    });

    // ---------- Boat / modes ----------
    const NORTH = -Math.PI/2;
    const MODE = { LOGO_IDLE:'LOGO_IDLE', PRE_IDLE:'PRE_IDLE', TRANSITION:'TRANSITION', ACTIVE:'ACTIVE' };
    let mode = MODE.LOGO_IDLE;              // start centered, facing north, full logo visible
    let lastUserTime = 0;
    const IDLE_AFTER = 12;                  // seconds to attempt idle
    const PRE_IDLE_WINDOW = 2.5;            // start wave easing before transition

    // movement feel (your values)
    const kayak = {
      x:0, y:0,
      angle:NORTH,
      tx:0, ty:0,
      maxSpeed:260, arriveGain:2.0,
      rollAmp:0.03, rollSpeed:0.8,
      heaveAmp:0.4,
      speed:0, turnRate:2.5
    };
    let initialized=false;

    // logotype fade (independent of kayak, which is always drawn)
    let logoAlpha = 1;           // start with logotype visible
    let logoAlphaTarget = 1;     // target alpha (idle: 1, active/transitions: 0)
    const LOGO_FADE_RATE = 0.8;  // per-second (lower = slower)

    // ---------- Wake (scaled) ----------
    const wake = { points:[], maxAge:1.6, minSpeed:40 };

    // ---------- Resize ----------
    function resize(){
      dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
      const w = canvas.clientWidth, h = canvas.clientHeight;
      canvas.width = Math.round(w*dpr); canvas.height = Math.round(h*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      width=w; height=h;
      if(!initialized){
        kayak.x=width/2; kayak.y=height/2; kayak.tx=kayak.x; kayak.ty=kayak.y; initialized=true;
      }else{
        kayak.x=clamp(kayak.x,0,width); kayak.y=clamp(kayak.y,0,height);
        kayak.tx=clamp(kayak.tx,0,width); kayak.ty=clamp(kayak.ty,0,height);
      }
      targetLength = mobileMQ.matches ? BASE_LENGTH_MOBILE : BASE_LENGTH_DESKTOP;
    }
    addEventListener('resize', resize, {passive:true}); resize();

    // ---------- Waves: rotated ribbons with eased rotation + controllable drift ----------
    const BASE_WAVE_ROT = -Math.PI * 0.375;       // NNE → SSW
    let waveRot = BASE_WAVE_ROT;
    let waveRotTarget = BASE_WAVE_ROT;
    const WAVE_ROT_EASE_RATE = 1.25;               // rad/s easing

    // drift offset (in rotated space)
    let waveFlowX = 0, waveFlowY = 0;
    const WAVE_FLOW_SPEED = 12;                    // px/sec in rotated space
    const WAVE_FLOW_DECAY = 0.9;                   // per-second decay when active

    const waves = {
      thickness: 28,
      baseAmp: 10,
      rowGap: 56,
      speedA: prefersReduce?0:0.55,
      speedB: prefersReduce?0:-0.22,
      dx: 5
    };

    // small value noise helpers
    function nrand(i){ let x = Math.sin(i*127.1)*43758.5453; return x - Math.floor(x); }
    function noise1(x, seed=0){
      const s = x*0.015 + seed*19.19;
      const i = Math.floor(s), f = s - i;
      const a = nrand(i*1.3+seed), b = nrand((i+1)*1.3+seed);
      const u = f*f*(3-2*f);
      return a*(1-u) + b*u;
    }
    function yWave(x, base, t, rowSeed){
      const k1 = 2*Math.PI/210, k2 = 2*Math.PI/137, k3 = 2*Math.PI/89;
      const p1 = k1*x + t*waves.speedA + rowSeed*1.3;
      const p2 = k2*x - t*waves.speedB + rowSeed*2.1;
      const p3 = k3*x + t*(waves.speedA*0.37) - rowSeed*0.7;
      const amp = waves.baseAmp * (0.8 + 0.6*noise1(x*0.4 + rowSeed*7));
      const jitter = (noise1(x*0.9 + t*0.15 + rowSeed*3)-0.5)*6;
      return base + (Math.sin(p1)*0.9 + Math.sin(p2)*0.5 + Math.sin(p3)*0.25)*amp + jitter;
    }

    function drawWaves(t){
      ctx.fillStyle = COLOR_LIGHT; ctx.fillRect(0,0,width,height);

      // ease wave rotation toward target
      const rotStep = 1 - Math.exp(-WAVE_ROT_EASE_RATE * Math.min(0.033, (timeSec - (lastFrameTime||timeSec))));
      waveRot += (waveRotTarget - waveRot) * rotStep;

      const diag = Math.hypot(width, height);
      const W = diag, H = diag;

      ctx.save();
      ctx.translate(width/2, height/2);
      ctx.rotate(waveRot);
      ctx.translate(-W/2, -H/2);

      // drift offset in rotated space
      ctx.translate(waveFlowX, waveFlowY);

      ctx.fillStyle = COLOR_DARK;
      drawLayer(t, 0.0, waves.rowGap, 0, W, H);
      ctx.globalAlpha = 0.75;
      drawLayer(t+3.1, waves.rowGap*0.5, waves.rowGap*0.92, 1, W, H);
      ctx.globalAlpha = 1;

      ctx.restore();
    }
    function drawLayer(t, yOffset, gap, seed, W, H){
      for(let base = yOffset - 60; base < H + gap; base += gap){
        drawRibbon(base, t, seed, W, H);
      }
    }
    function drawRibbon(base, t, seed, W, H){
      const thick = waves.thickness, dx = waves.dx;
      ctx.beginPath();
      let x=0, y=yWave(0, base, t, seed);
      ctx.moveTo(0, y - thick/2);
      for(x=0; x<=W; x+=dx){ y = yWave(x, base, t, seed); ctx.lineTo(x, y - thick/2); }
      for(x=W; x>=0; x-=dx){ y = yWave(x, base, t, seed); ctx.lineTo(x, y + thick/2); }
      ctx.closePath(); ctx.fill();
    }

    // ---------- Motion / state ----------
    function angDiff(a,b){ let d=(b-a+Math.PI)%(2*Math.PI); if(d<0)d+=2*Math.PI; return d-Math.PI; }
    function approachAngle(a, target, rate, dt){
      const d = angDiff(a, target);
      return a + d * (1 - Math.exp(-rate * dt)); // smooth exponential approach
    }
    const IDLE_DIST = 0.5;

    function setMode(newMode){
      mode = newMode;
      // logotype fades out during non-idle; fades in during idle
      logoAlphaTarget = (mode === MODE.LOGO_IDLE) ? 1 : 0;
    }

    function applyWaveFlowTowardCenter(strength, dt){
      const cx = width/2, cy = height/2;
      const dx = cx - kayak.x, dy = cy - kayak.y;
      const dist = Math.hypot(dx,dy) || 1;
      const vx = dx/dist, vy = dy/dist;              // screen-space unit vector
      // rotate into current wave space (inverse of waveRot)
      const cosR = Math.cos(-waveRot), sinR = Math.sin(-waveRot);
      const vrx = vx * cosR - vy * sinR;
      const vry = vx * sinR + vy * cosR;
      waveFlowX += vrx * WAVE_FLOW_SPEED * strength * dt;
      waveFlowY += vry * WAVE_FLOW_SPEED * strength * dt;
      const wrap = waves.rowGap;
      if (waveFlowX >  2*wrap) waveFlowX -= 2*wrap; if (waveFlowX < -2*wrap) waveFlowX += 2*wrap;
      if (waveFlowY >  2*wrap) waveFlowY -= 2*wrap; if (waveFlowY < -2*wrap) waveFlowY += 2*wrap;
    }

    function updateBoatAndWaves(dt){
      // size easing
      const k = Math.min(1, SIZE_EASE_PER_SEC * dt);
      currentLength += (targetLength - currentLength) * k;

      // logo fade easing
      const fadeK = 1 - Math.exp(-LOGO_FADE_RATE * dt);
      logoAlpha += (logoAlphaTarget - logoAlpha) * fadeK;
      logoAlpha = clamp(logoAlpha, 0, 1);

      const cx = width/2, cy = height/2;
      const dx = kayak.tx-kayak.x, dy = kayak.ty-kayak.y, dist = Math.hypot(dx,dy);
      const px = kayak.x, py = kayak.y;

      // --- Mode transitions ---
      const since = timeSec - lastUserTime;
      if (mode === MODE.ACTIVE){
        // decay wave flow & ease rotation to base while active
        const decay = Math.pow(WAVE_FLOW_DECAY, dt);
        waveFlowX *= decay; waveFlowY *= decay;
        waveRotTarget = BASE_WAVE_ROT;

        if (since >= (IDLE_AFTER - PRE_IDLE_WINDOW) && dist <= IDLE_DIST){
          setMode(MODE.PRE_IDLE);
        }
      }
      else if (mode === MODE.PRE_IDLE){
        // gently nudge waves toward center BEFORE we enter transition
        applyWaveFlowTowardCenter(0.8, dt);

        // ease wave rotation slightly for visual shift (not huge)
        const angToCenter = Math.atan2(cy - kayak.y, cx - kayak.x);
        const desiredRot = BASE_WAVE_ROT + clamp(angDiff(BASE_WAVE_ROT, angToCenter - Math.PI/2), -0.25, 0.25) * 0.25;
        waveRotTarget = desiredRot;

        if (since >= IDLE_AFTER && dist <= IDLE_DIST){
          kayak.tx = cx; kayak.ty = cy;
          setMode(MODE.TRANSITION);
        }
      }
      else if (mode === MODE.TRANSITION){
        // ease position to center
        const toCdx = cx-kayak.x, toCdy = cy-kayak.y, toCdist = Math.hypot(toCdx,toCdy);
        const dirX = toCdist>1e-3 ? toCdx/toCdist : 0, dirY = toCdist>1e-3 ? toCdy/toCdist : 0;
        const desired = Math.min(kayak.maxSpeed*0.5, toCdist * (kayak.arriveGain*0.9));
        kayak.x += dirX * desired * dt; kayak.y += dirY * desired * dt;

        // slow gentle yaw to NORTH
        kayak.angle = approachAngle(kayak.angle, NORTH, 0.8, dt);

        // waves push toward center and ease rotation back near base
        applyWaveFlowTowardCenter(1.0, dt);
        waveRotTarget = BASE_WAVE_ROT;

        // settle into idle when centered-ish
        if (toCdist < 1.2){
          setMode(MODE.LOGO_IDLE);   // this will fade the logo in smoothly
          kayak.x = cx; kayak.y = cy; kayak.angle = NORTH;
        }
      }
      else if (mode === MODE.LOGO_IDLE){
        // always north-ish
        kayak.angle = approachAngle(kayak.angle, NORTH, 1.2, dt);

        // *** weaker recentering so it can drift ~4× farther ***
        const toCdx = cx-kayak.x, toCdy = cy-kayak.y, toCdist = Math.hypot(toCdx,toCdy);
        if (toCdist > 0.25){
          const dirX = toCdx/toCdist, dirY = toCdy/toCdist;
          const drift = Math.min(7, toCdist*0.5); // was 18 / 2 → 4× weaker pull
          kayak.x += dirX * drift * dt; kayak.y += dirY * drift * dt;
        }

        // waves: slow ambient rotation + slight inward drift
        waveRotTarget = BASE_WAVE_ROT + 0.10 * Math.sin(timeSec * 0.08);
        applyWaveFlowTowardCenter(0.35, dt);
      }

      // --- ACTIVE boat movement ---
      if (mode === MODE.ACTIVE){
        if (dist > IDLE_DIST){
          const dirX=dx/dist, dirY=dy/dist;
          const desired=Math.min(kayak.maxSpeed, dist*kayak.arriveGain);
          kayak.x += dirX*desired*dt; kayak.y += dirY*desired*dt;

          const desiredAngle = Math.atan2(dirY,dirX);
          const diff = angDiff(kayak.angle, desiredAngle);
          const maxStep = kayak.turnRate*dt;
          kayak.angle += Math.sign(diff)*Math.min(Math.abs(diff), maxStep);
        }
      }

      // compute speed
      kayak.speed = Math.hypot(kayak.x - px, kayak.y - py) / dt;
    }

    // ---------- Wake ----------
    function updateWake(dt){
      for (let i=0;i<wake.points.length;i++) wake.points[i].age+=dt;
      while(wake.points.length && wake.points[0].age>wake.maxAge) wake.points.shift();

      const sternOffset = (currentLength/2 - 2);
      if(kayak.speed > wake.minSpeed && mode !== MODE.LOGO_IDLE){
        const sx = kayak.x - Math.cos(kayak.angle)*sternOffset;
        const sy = kayak.y - Math.sin(kayak.angle)*sternOffset;
        const last = wake.points[wake.points.length-1];
        const sampleDist = currentLength * 0.028;
        if(!last || Math.hypot(sx-last.x, sy-last.y) >= sampleDist){
          wake.points.push({x:sx,y:sy,age:0});
        }
      }
    }
    function drawWake(){
      const pts=wake.points; if(pts.length<2) return;
      ctx.save(); ctx.strokeStyle='#fff'; ctx.lineCap='round'; ctx.lineJoin='round';
      for(let i=1;i<pts.length;i++){
        const p0=pts[i-1], p1=pts[i];
        const a = Math.min(1 - p0.age/wake.maxAge, 1 - p1.age/wake.maxAge);
        if(a<=0) continue;
        const spreadMax = currentLength * 0.13;

        ctx.globalAlpha=0.18*a*a; ctx.lineWidth=6*a;
        ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();

        const vx=p1.x-p0.x, vy=p1.y-p0.y, len=Math.hypot(vx,vy);
        if(len>1e-3){
          const nx=vx/len, ny=vy/len, px=-ny, py=nx;
          const s0=spreadMax*(1 - p0.age/wake.maxAge);
          const s1=spreadMax*(1 - p1.age/wake.maxAge);
          ctx.globalAlpha=0.12*a*a; ctx.lineWidth=3*a;
          ctx.beginPath(); ctx.moveTo(p0.x+px*s0,p0.y+py*s0); ctx.lineTo(p1.x+px*s1,p1.y+py*s1); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(p0.x-px*s0,p0.y-py*s0); ctx.lineTo(p1.x-px*s1,p1.y-py*s1); ctx.stroke();
        }
      }
      ctx.restore();
    }

    // ---------- Draw boat (center-pivot yaw; kayak always drawn, logotype fades) ----------
    function drawBoat(t){
      ctx.save();
      const heave = Math.sin(t * kayak.rollSpeed * 2*Math.PI) * kayak.heaveAmp;
      const roll  = Math.sin(t * kayak.rollSpeed * 2*Math.PI) * kayak.rollAmp;
      ctx.translate(kayak.x, kayak.y + heave);
      ctx.rotate(kayak.angle + roll);

      const L = currentLength;

      // Draw kayak (always visible)
      if (kayakLoaded){
        ctx.save();
        ctx.rotate(Math.PI/2); // SVG faces north
        const targetH = L;
        const ratio = kayakImg.naturalWidth / kayakImg.naturalHeight || 1;
        const w = targetH * ratio, h = targetH;
        ctx.globalAlpha = 1;
        ctx.drawImage(kayakImg, -w/2, -h/2, w, h);
        ctx.restore();
      } else {
        // fallback hull
        ctx.save();
        const W = L * (40/140);
        ctx.fillStyle=COLOR_KAYAK; ctx.strokeStyle=COLOR_DARK; ctx.lineWidth=2;
        ctx.beginPath();
        ctx.moveTo(+L/2,0);
        ctx.quadraticCurveTo(+L/6,-W/2,0,-W/2.4);
        ctx.quadraticCurveTo(-L/3,-W/3,-L/2,0);
        ctx.quadraticCurveTo(-L/3,+W/3,0,+W/2.4);
        ctx.quadraticCurveTo(+L/6,+W/2,+L/2,0);
        ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.restore();
      }

      // Draw logotype on top (fades in/out)
      if (logoLoaded && logoAlpha > 0.001){
        ctx.save();
        ctx.rotate(Math.PI/2); // faces north
        const targetH = L;
        const ratio = logoImg.naturalWidth / logoImg.naturalHeight || 1;
        const w = targetH * ratio, h = targetH;
        ctx.globalAlpha = logoAlpha;
        ctx.drawImage(logoImg, -w/2, -h/2, w, h);
        ctx.restore();
      }

      ctx.restore();
    }

    // ---------- Ripple ----------
    const ripple={x:0,y:0,t0:-10};
    function drawRipple(t){
      const e=t-ripple.t0; if(e<0||e>1.2) return;
      const a=1-(e/1.2);
      ctx.save(); ctx.translate(ripple.x,ripple.y); ctx.strokeStyle=COLOR_DARK; ctx.globalAlpha=0.35*a; ctx.lineWidth=2;
      circle(e*140); circle(16+e*180); ctx.restore();
      function circle(r){ ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke(); }
    }

    // ---------- Input / idle hint ----------
    const hint = document.getElementById('hint');
    let hintTimer=null;
    function scheduleHint(){
      if(hintTimer) clearTimeout(hintTimer);
      hint.classList.remove('show');
      hintTimer = setTimeout(()=>hint.classList.add('show'), 30000);
    }
    scheduleHint();

    // pointer state
    let pointerDown=false, pointerPresent=false, pointerX=0, pointerY=0;

    function canvasToLocal(e){
      const r = canvas.getBoundingClientRect();
      return { x: e.clientX - r.left, y: e.clientY - r.top };
    }

    // Move boat target (sets ripple & ACTIVE)
    function moveBoatTo(x,y){
      kayak.tx=x; kayak.ty=y;
      ripple.x=x; ripple.y=y; ripple.t0=timeSec;
    }

    canvas.addEventListener('pointerenter',()=>{ pointerPresent=true; });
    canvas.addEventListener('pointerleave',()=>{ pointerPresent=false; pointerDown=false; });
    canvas.addEventListener('pointermove',(e)=>{ const p=canvasToLocal(e); pointerX=p.x; pointerY=p.y; });

    canvas.addEventListener('pointerdown',(e)=>{
      pointerDown = true;
      const p = canvasToLocal(e); pointerX=p.x; pointerY=p.y;

      if (mode === MODE.LOGO_IDLE){
        // idle: don't move yet; fade logotype out slowly as we LEAVE idle
        lastUserTime = timeSec;
        setMode(MODE.ACTIVE); // sets logoAlphaTarget=0 (fade-out)
      } else {
        // non-idle: move immediately on press
        moveBoatTo(p.x, p.y);
        lastUserTime = timeSec; setMode(MODE.ACTIVE);
      }

      hint.classList.remove('show'); scheduleHint();
    }, {passive:true});

    canvas.addEventListener('pointerup',(e)=>{
      const p = canvasToLocal(e); pointerX=p.x; pointerY=p.y;
      pointerDown = false;

      // In idle, we move on release (per spec)
      if (mode === MODE.ACTIVE){
        moveBoatTo(p.x, p.y);
        lastUserTime = timeSec;
      }
    }, {passive:true});
    canvas.addEventListener('pointercancel',()=>{ pointerDown=false; });

    // ---------- Idle interactive bias toward cursor ----------
    function idleCursorBias(dt){
      if (mode !== MODE.LOGO_IDLE) return;
      if (!pointerPresent) return;

      const cx = kayak.x, cy = kayak.y;
      const dx = pointerX - cx, dy = pointerY - cy;
      const dist = Math.hypot(dx,dy);
      if (dist < 1) return;

      const dirX = dx/dist, dirY = dy/dist;
      const biasSpeed = pointerDown ? 44 : 12; // ~4x stronger than before overall
      kayak.x += dirX * biasSpeed * dt;
      kayak.y += dirY * biasSpeed * dt;
    }

    // Pause hint timer when tab hidden (resume on return)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) { if (hintTimer) clearTimeout(hintTimer); }
      else { scheduleHint(); }
    });

    // footer year
    document.getElementById('year').textContent = new Date().getFullYear();

    // ---------- Main loop ----------
    let lastFrameTime = timeSec;
    function frame(now){
      const dt=Math.min(0.033,(now-last)/1000); last=now; timeSec+=dt;

      updateBoatAndWaves(dt);
      idleCursorBias(dt);
      updateWake(dt);

      drawWaves(timeSec);
      drawWake();
      drawRipple(timeSec);
      drawBoat(timeSec);

      lastFrameTime = timeSec;
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>

  <script type="application/ld+json">
  {"@context":"https://schema.org","@type":"Organization","name":"Bak-Yak Inc.","alternateName":"BakYak","url":"https://bakyak.ca","logo":"https://bakyak.ca/assets/logotype.svg"}
  </script>
</body>
</html>
