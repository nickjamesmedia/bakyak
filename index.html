<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BakYak — Collapsible Kayak Backpack | Coming Soon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="BakYak (Bak-Yak Inc.) — the collapsible kayak you carry as a backpack. Coming soon." />
  <link rel="canonical" href="https://bakyak.ca/">
  <meta name="theme-color" content="#C8692D" />
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self';
                 img-src 'self' data:;
                 style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
                 font-src https://fonts.gstatic.com;
                 script-src 'self' 'unsafe-inline';
                 frame-ancestors 'none'">
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@1,700&display=swap" rel="stylesheet">
  <style>
    :root{
      --light:#82C4D8;  /* water (light) */
      --dark:#3249A2;   /* waves (dark) */
      --text:#C8692D;   /* burnt orange */
    }
    html,body{
      height:100%;
      margin:0;
      background:var(--light);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      text-rendering:optimizeLegibility;
    }
    .wrap{position:relative;width:100vw;height:100vh;overflow:hidden;}
    .mast{
      position:fixed;top:12px;left:50%;transform:translateX(-50%);
      font:italic 700 28px/1 "Barlow",system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;
      letter-spacing:.02em;user-select:none;text-shadow:0 1px 0 #ffffff66;
    }
    #game{width:100%;height:100%;display:block;touch-action:manipulation;}
    .hint{
      position:fixed;left:12px;bottom:12px;
      font:600 12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;
      color:var(--text);background:#ffffff66;padding:6px 8px;border-radius:6px;
      user-select:none;backdrop-filter:blur(4px);opacity:0;transition:opacity .8s ease;
    }
    .hint.show{opacity:.9;}
    .copy{
      position:fixed;right:12px;bottom:10px;
      font:600 12px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;
      color:var(--text);text-shadow:0 1px 0 #ffffff66;user-select:none;
    }
    @media (prefers-reduced-motion: reduce){#game{animation:none;}}
  </style>
</head>
<body>
  <div class="wrap" aria-label="BakYak coming soon interactive scene">
    <div class="mast" aria-hidden="true">coming soon…</div>
    <canvas id="game"></canvas>
    <div class="hint" id="hint">Click to move the kayak</div>
    <div class="copy">© <span id="year"></span> Bak-Yak Inc.</div>
  </div>
  <noscript>This page is interactive. Enable JavaScript to play with the kayak.</noscript>

  <script>
  (() => {
    'use strict';
    // ---- Helpers / Config ----
    const COLOR_LIGHT = css('--light','#82C4D8');
    const COLOR_DARK  = css('--dark', '#3249A2');
    const COLOR_KAYAK = '#C8692D';
    function css(v,f){ const x=getComputedStyle(document.documentElement).getPropertyValue(v).trim(); return x||f; }
    function clamp(v,lo,hi){ return Math.max(lo,Math.min(hi,v)); }

    // ---- Canvas ----
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    let width=0, height=0;

    // ---- Time / state ----
    let timeSec = 0, last = performance.now();
    const prefersReduce = matchMedia && matchMedia('(prefers-reduced-motion: reduce)').matches;

    // ---- Kayak ----
    const KAYAK_LENGTH = 125;       // 2× size
    const kayak = {
      x:0, y:0,
      angle:-Math.PI/2,             // start facing north
      tx:0, ty:0,
      maxSpeed:260, arriveGain:2.0,
      rollAmp:0.03, rollSpeed:0.8,  // ~4° side-to-side rock (port/starboard)
      heaveAmp:0.4,                 // tiny vertical heave
      speed:0, turnRate:2.5
    };
    let initialized=false;

    // SVG-first kayak
    const kayakImg = new Image();
    kayakImg.decoding='async';
    kayakImg.src='assets/kayak.svg';
    let kayakImgLoaded=false;
    kayakImg.onload=()=>{kayakImgLoaded=true;};

    // ---- Wake ----
    const wake = { points:[], maxAge:1.6, minSpeed:40, sampleDist:3.5, spreadMax:18 };

    // ---- Resize ----
    function resize(){
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
      const w = canvas.clientWidth, h = canvas.clientHeight;
      canvas.width = Math.round(w*dpr); canvas.height = Math.round(h*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      width=w; height=h;
      if(!initialized){
        kayak.x=width/2; kayak.y=height/2; kayak.tx=kayak.x; kayak.ty=kayak.y; initialized=true;
      }else{
        kayak.x=clamp(kayak.x,0,width); kayak.y=clamp(kayak.y,0,height);
        kayak.tx=clamp(kayak.tx,0,width); kayak.ty=clamp(kayak.ty,0,height);
      }
    }
    addEventListener('resize', resize, {passive:true}); resize();

    // ---- Abstract Waves (multi-harmonic + soft noise) ----
    const waves = {
      thickness: 28,
      baseAmp: 10,
      rowGap: 56,
      speedA: prefersReduce?0:0.55,
      speedB: prefersReduce?0:-0.22,
      dx: 5
    };
    // quick 1D value noise
    function nrand(i){ // deterministic 0..1
      let x = Math.sin(i*127.1)*43758.5453; return x - Math.floor(x);
    }
    function noise1(x, seed=0){
      const s = x*0.015 + seed*19.19;
      const i = Math.floor(s), f = s - i;
      const a = nrand(i*1.3+seed), b = nrand((i+1)*1.3+seed);
      const u = f*f*(3-2*f);
      return a*(1-u) + b*u; // 0..1
    }
    function yWave(x, base, t, rowSeed){
      // blend of sines with incommensurate wavelengths + slow noise
      const k1 = 2*Math.PI/210, k2 = 2*Math.PI/137, k3 = 2*Math.PI/89;
      const p1 = k1*x + t*waves.speedA + rowSeed*1.3;
      const p2 = k2*x - t*waves.speedB + rowSeed*2.1;
      const p3 = k3*x + t*(waves.speedA*0.37) - rowSeed*0.7;
      const amp = waves.baseAmp * (0.8 + 0.6*noise1(x*0.4 + rowSeed*7));
      const jitter = (noise1(x*0.9 + t*0.15 + rowSeed*3)-0.5)*6;
      return base + (Math.sin(p1)*0.9 + Math.sin(p2)*0.5 + Math.sin(p3)*0.25)*amp + jitter;
    }
    function drawWaves(t){
      ctx.fillStyle = COLOR_LIGHT; ctx.fillRect(0,0,width,height);
      ctx.fillStyle = COLOR_DARK;

      // two semi-overlapping layers with different seeds/gaps
      drawLayer(t, 0.0, waves.rowGap, 0);
      ctx.globalAlpha = 0.75;
      drawLayer(t+3.1, waves.rowGap*0.5, waves.rowGap*0.92, 1);
      ctx.globalAlpha = 1;
    }
    function drawLayer(t, yOffset, gap, seed){
      for(let base = yOffset - 60; base < height + gap; base += gap){
        drawRibbon(base, t, seed);
      }
    }
    function drawRibbon(base, t, seed){
      const thick = waves.thickness;
      const dx = waves.dx;
      ctx.beginPath();
      let x=0, y=yWave(0, base, t, seed);
      ctx.moveTo(0, y - thick/2);
      for(x=0; x<=width; x+=dx){ y = yWave(x, base, t, seed); ctx.lineTo(x, y - thick/2); }
      for(x=width; x>=0; x-=dx){ y = yWave(x, base, t, seed); ctx.lineTo(x, y + thick/2); }
      ctx.closePath(); ctx.fill();
    }

    // ---- Motion ----
    function angDiff(a,b){ let d=(b-a+Math.PI)%(2*Math.PI); if(d<0)d+=2*Math.PI; return d-Math.PI; }
    function updateKayak(dt){
      const dx = kayak.tx-kayak.x, dy = kayak.ty-kayak.y, dist = Math.hypot(dx,dy);
      const px = kayak.x, py = kayak.y;
      if(dist>0.5){
        const dirX=dx/dist, dirY=dy/dist;
        const desired=Math.min(kayak.maxSpeed, dist*kayak.arriveGain);
        kayak.x += dirX*desired*dt; kayak.y += dirY*desired*dt;
        const desiredAngle = Math.atan2(dirY,dirX);
        const diff = angDiff(kayak.angle, desiredAngle);
        const maxStep = kayak.turnRate*dt;
        kayak.angle += Math.sign(diff)*Math.min(Math.abs(diff), maxStep);
      }
      kayak.speed = Math.hypot(kayak.x-px, kayak.y-py)/dt;
    }

    // ---- Wake ----
    function updateWake(dt){
      for (let i=0;i<wake.points.length;i++) wake.points[i].age+=dt;
      while(wake.points.length && wake.points[0].age>wake.maxAge) wake.points.shift();
      if(kayak.speed > wake.minSpeed){
        const sx = kayak.x - Math.cos(kayak.angle)*(KAYAK_LENGTH/2 - 2);
        const sy = kayak.y - Math.sin(kayak.angle)*(KAYAK_LENGTH/2 - 2);
        const last = wake.points[wake.points.length-1];
        if(!last || Math.hypot(sx-last.x, sy-last.y) >= wake.sampleDist){
          wake.points.push({x:sx,y:sy,age:0});
        }
      }
    }
    function drawWake(){
      const pts=wake.points; if(pts.length<2) return;
      ctx.save(); ctx.strokeStyle='#fff'; ctx.lineCap='round'; ctx.lineJoin='round';
      for(let i=1;i<pts.length;i++){
        const p0=pts[i-1], p1=pts[i];
        const a = Math.min(1 - p0.age/wake.maxAge, 1 - p1.age/wake.maxAge);
        if(a<=0) continue;
        ctx.globalAlpha=0.18*a*a; ctx.lineWidth=6*a;
        ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();
        const vx=p1.x-p0.x, vy=p1.y-p0.y, len=Math.hypot(vx,vy);
        if(len>1e-3){
          const nx=vx/len, ny=vy/len, px=-ny, py=nx;
          const s0=wake.spreadMax*(1 - p0.age/wake.maxAge);
          const s1=wake.spreadMax*(1 - p1.age/wake.maxAge);
          ctx.globalAlpha=0.12*a*a; ctx.lineWidth=3*a;
          ctx.beginPath(); ctx.moveTo(p0.x+px*s0,p0.y+py*s0); ctx.lineTo(p1.x+px*s1,p1.y+py*s1); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(p0.x-px*s0,p0.y-py*s0); ctx.lineTo(p1.x-px*s1,p1.y-py*s1); ctx.stroke();
        }
      }
      ctx.restore();
    }

    // ---- Draw Kayak (SVG first, fallback) ----
    function drawKayak(t){
      ctx.save();
      // slight heave + port/starboard roll
      const heave = Math.sin(t * kayak.rollSpeed * 2*Math.PI) * kayak.heaveAmp;
      const roll  = Math.sin(t * kayak.rollSpeed * 2*Math.PI) * kayak.rollAmp;

      ctx.translate(kayak.x, kayak.y + heave);
      // base heading + roll (side-to-side)
      ctx.rotate(kayak.angle + roll);

      if(kayakImgLoaded){
        // SVG faces north; add +90° so "forward" is +X before we rotated kayak.angle
        ctx.rotate(Math.PI/2);
        const targetH = KAYAK_LENGTH;
        const ratio = kayakImg.naturalWidth / kayakImg.naturalHeight || 1;
        const drawW = targetH * ratio, drawH = targetH;
        ctx.drawImage(kayakImg, -drawW/2, -drawH/2, drawW, drawH);
      }else{
        const L=KAYAK_LENGTH, W=40;
        ctx.fillStyle=COLOR_KAYAK; ctx.strokeStyle=COLOR_DARK; ctx.lineWidth=2;

        ctx.beginPath();
        ctx.moveTo(+L/2,0);
        ctx.quadraticCurveTo(+L/6,-W/2,0,-W/2.4);
        ctx.quadraticCurveTo(-L/3,-W/3,-L/2,0);
        ctx.quadraticCurveTo(-L/3,+W/3,0,+W/2.4);
        ctx.quadraticCurveTo(+L/6,+W/2,+L/2,0);
        ctx.closePath(); ctx.fill(); ctx.stroke();

        // center line
        ctx.beginPath(); ctx.moveTo(-L/2+10,0); ctx.lineTo(L/2-10,0);
        ctx.lineWidth=2; ctx.stroke();

        // cockpit
        ctx.beginPath();
        const c=0.552284749831, cx=-L*0.05, cy=0, rx=24, ry=12;
        ctx.moveTo(cx+rx,cy);
        ctx.bezierCurveTo(cx+rx,cy+ry*c,cx+rx*c,cy+ry,cx,cy+ry);
        ctx.bezierCurveTo(cx-rx*c,cy+ry,cx-rx,cy+ry*c,cx-rx,cy);
        ctx.bezierCurveTo(cx-rx,cy-ry*c,cx-rx*c,cy-ry,cx,cy-ry);
        ctx.bezierCurveTo(cx+rx*c,cy-ry,cx+rx,cy-ry*c,cx+rx,cy);
        ctx.fillStyle='#fff'; ctx.fill(); ctx.lineWidth=2; ctx.stroke();
      }
      ctx.restore();
    }

    // ---- Ripple ----
    const ripple={x:0,y:0,t0:-10};
    function drawRipple(t){
      const e=t-ripple.t0; if(e<0||e>1.2) return;
      const a=1-(e/1.2);
      ctx.save(); ctx.translate(ripple.x,ripple.y); ctx.strokeStyle=COLOR_DARK; ctx.globalAlpha=0.35*a; ctx.lineWidth=2;
      circle(e*140); circle(16+e*180); ctx.restore();
      function circle(r){ ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke(); }
    }

    // ---- Input & Hint logic (inactivity-based) ----
    const hint = document.getElementById('hint');
    let hintTimer=null;
    function scheduleHint(){
      if(hintTimer) clearTimeout(hintTimer);
      hint.classList.remove('show');
      hintTimer = setTimeout(()=>hint.classList.add('show'), 30000); // show after 30s idle
    }
    scheduleHint();

    function moveKayakTo(x,y){
      kayak.tx=x; kayak.ty=y;
      ripple.x=x; ripple.y=y; ripple.t0=timeSec;
    }
    canvas.addEventListener('pointerdown',(e)=>{
      const r=canvas.getBoundingClientRect();
      moveKayakTo(e.clientX - r.left, e.clientY - r.top);
      hint.classList.remove('show');  // hide on click
      scheduleHint();                 // restart inactivity timer
    }, {passive:true});

    // ---- Misc ----
    document.getElementById('year').textContent = new Date().getFullYear();

    // ---- Main loop ----
    function frame(now){
      const dt=Math.min(0.033,(now-last)/1000); last=now; timeSec+=dt;
      updateKayak(dt); updateWake(dt);
      drawWaves(timeSec);
      drawWake(); drawRipple(timeSec); drawKayak(timeSec);
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>

  <script type="application/ld+json">
  {"@context":"https://schema.org","@type":"Organization","name":"Bak-Yak Inc.","alternateName":"BakYak","url":"https://bakyak.ca","logo":"https://bakyak.ca/assets/kayak.svg"}
  </script>
</body>
</html>
